---
title: "Boot Chain: ROM to Bootloader to Kernel"
weight: 40
---

# Boot Chain: ROM to Bootloader to Kernel

An MCU boots in microseconds — power on, fetch from reset vector, start executing firmware. An MPU boots in seconds through a multi-stage chain: ROM code, first-stage bootloader, second-stage bootloader, kernel, and finally user space. Each stage initializes just enough hardware to load the next. Understanding this chain is essential because boot failures are common and opaque without knowing where in the sequence things went wrong.

## MCU Boot vs MPU Boot

On an MCU, boot is almost trivially simple. The processor comes out of reset, reads the initial stack pointer and reset vector from the vector table (usually at address `0x0000_0000` or aliased there), and starts executing. The startup code initializes `.data` and `.bss`, sets up the clock tree, and calls `main()`. The whole process is a single stage, entirely deterministic, and completes in milliseconds. There is nothing to configure, nothing to find, and nothing that can go wrong beyond corrupted flash — which you would notice immediately. This is covered in detail in [Startup & Initialization]({{< relref "/docs/embedded/firmware-structure/startup-and-initialization" >}}) and [Power-Up & Reset]({{< relref "/docs/embedded/embedded-reality/power-up-and-reset" >}}).

MPU boot is fundamentally different because of one problem: DRAM. The kernel needs tens or hundreds of megabytes of working memory, and that memory lives in external DDR chips that require complex initialization — clock training, impedance calibration, timing parameter configuration. This initialization requires running code, but the code needs somewhere to live while it runs. External DRAM is not available yet. The SoC's internal SRAM is tiny — typically 64 KB to 256 KB — not enough for a kernel, but enough for a small bootloader.

This chicken-and-egg problem is why MPU boot has multiple stages. Each stage runs in whatever memory is available, initializes the next piece of hardware, and loads the next (larger) stage into the newly available memory. Boot ROM runs from internal SRAM and loads a first-stage bootloader. The first-stage bootloader initializes DRAM and loads the full bootloader into it. The full bootloader loads the kernel. The kernel mounts the root filesystem and starts user space. Each handoff is a potential failure point, and each one is harder to debug than the last because there is less infrastructure available.

What is surprising at first is how much of the boot chain is invisible. On an MCU, every instruction from reset can be stepped through in a JTAG debugger. On an MPU, the boot ROM is in mask ROM with no source code, the first-stage bootloader might produce no output at all unless a serial console is connected, and by the time anything appears on screen, the system has already executed millions of instructions across three or four software stages. The serial console becomes the single most important debugging tool for embedded Linux — more on that in the gotchas.

## The Boot ROM

The boot ROM is code burned into the silicon by the SoC vendor at fabrication time. It is mask ROM — literally part of the chip's physical structure — and it cannot be modified, updated, or patched. When the processor comes out of reset, this is the first code that executes. It runs entirely from the SoC's small internal SRAM, because nothing else is initialized yet.

The boot ROM's job is narrow but critical. It initializes the minimum set of peripherals needed to load external code: basic clock configuration, enough pinmux setup to talk to the boot media, and the interface to that media (SD/MMC controller, SPI controller, NAND controller, USB, or UART). It then searches for a valid first-stage bootloader image on the configured boot device, loads it into internal SRAM, and jumps to it.

How the boot ROM knows where to look is platform-specific but usually involves hardware straps — GPIO pins that are sampled at reset and latched. On a BeagleBone Black (AM335x), for example, specific pins determine whether the SoC boots from NAND, eMMC, SD card, UART, or USB. These pins are typically connected to resistors on the PCB or exposed on a header for development. Some newer SoCs use eFuses (one-time programmable memory) for boot configuration in production, with strap pins as a development override.

One behavior of the boot ROM that is particularly useful during board bring-up: many SoCs implement a fallback or recovery mode. If the boot ROM cannot find a valid image on the primary boot device — no valid header, checksum failure, or no media present — it falls back to USB or UART boot. This means you can load code over a USB cable even on a board with a blank eMMC. TI's AM335x falls back to UART and USB; NXP's i.MX series has a serial download mode; Allwinner SoCs have FEL mode via USB. These recovery modes are invaluable, because without them, a corrupted bootloader on eMMC would mean a bricked board with no recovery path short of desoldering the flash chip.

The boot ROM is almost always poorly documented or entirely undocumented. Vendors may publish a few pages about the boot image format and header structure — enough to get a bootloader loaded — but the actual ROM code is proprietary. This means when something goes wrong in the boot ROM stage, your diagnostic tools are limited: does the SoC pull a status pin high? Does it enter recovery mode? Does it output anything on UART? In many cases the answer is no, and you are left inferring what happened from what did not happen.

## Bootloader: U-Boot and Alternatives

U-Boot (Das U-Boot) is the dominant bootloader in the embedded Linux world, and understanding it is practically mandatory for MPU-based development. U-Boot is open source, supports hundreds of SoCs and boards, and provides a rich command-line environment for loading and booting kernels. Most SBC vendors (Raspberry Pi being a notable exception with its own proprietary bootloader) ship U-Boot as the default bootloader.

On most platforms, U-Boot runs as two stages. The first stage is called SPL (Secondary Program Loader) or sometimes TPL (Tertiary Program Loader) on platforms that need an even earlier stage. SPL must fit in the SoC's internal SRAM — often 64-128 KB — so it is a stripped-down version of U-Boot containing only the code needed to initialize DRAM and load the full U-Boot binary. SPL initializes the DDR controller with the correct timing parameters for the specific DRAM chips on the board (this is one of the most board-specific and finicky parts of a port), then loads full U-Boot from the boot media into DRAM and jumps to it.

Full U-Boot runs from DRAM and provides a surprisingly capable environment. It has a command-line interface accessible over the serial console, supports reading files from FAT and ext4 filesystems, can boot from the network via TFTP, and understands device trees. It maintains a set of environment variables that control boot behavior — which device to boot from, the kernel command line, the addresses where the kernel and device tree should be loaded, and boot scripts that automate the process. These environment variables are typically stored in a dedicated partition or at a known offset on the boot media, separate from the bootloader binary itself.

A typical U-Boot boot sequence looks like this: U-Boot starts, runs its initialization, then executes the `bootcmd` environment variable, which is a script. A common `bootcmd` might load a kernel image and device tree blob from the first partition of an SD card, set the kernel command line to specify the root filesystem location, and then issue a `bootz` (for zImage) or `booti` (for Image) command to hand off to the kernel. When things go wrong, you can interrupt the automatic boot by pressing a key on the serial console, which drops you into the U-Boot shell where you can manually inspect the boot media, load files, examine memory, and test configurations.

Alternatives to U-Boot exist but are less common. Barebox is a more modern bootloader with cleaner internals and native device tree support — it is sometimes described as what U-Boot would look like if rewritten from scratch. Coreboot focuses on x86 platforms and is used in Chromebooks. The Raspberry Pi uses a proprietary bootloader (`bootcode.bin` and `start.elf`) provided by Broadcom that runs on the VideoCore GPU before the ARM cores even start — a completely different architecture from the standard boot chain. Vendor-specific bootloaders appear on some SoCs, particularly from Chinese manufacturers (Allwinner, Rockchip), where the mainline U-Boot port may lag behind what the vendor ships.

One thing worth appreciating is how much configuration lives in U-Boot rather than in the kernel. The kernel command line — including the root filesystem device, console settings, and various boot-time options — is assembled and passed by U-Boot. The device tree blob is loaded by U-Boot and its address passed to the kernel. If U-Boot loads the wrong device tree or passes a bad command line, the kernel will fail in ways that look like kernel bugs but are really bootloader configuration errors. Learning to inspect and modify U-Boot's environment is an essential debugging skill.

## Loading the Kernel

Once U-Boot is running in DRAM with access to the boot media, its primary job is loading three things into specific memory addresses: the kernel image, the device tree blob, and optionally an initial RAM filesystem. The details of how these are loaded and where they go vary by platform, but the general pattern is consistent across ARM-based embedded Linux systems.

The kernel image comes in several formats. `zImage` is a compressed kernel with a self-extracting wrapper, common on 32-bit ARM. `Image` is an uncompressed kernel, standard on 64-bit ARM (AArch64). The FIT (Flattened Image Tree) format bundles the kernel, device tree, and optionally an initramfs into a single image with checksums and optional signatures — it is increasingly preferred for production systems because it enables verified boot. U-Boot loads the image into a specific DRAM address (defined in the U-Boot configuration or environment), then uses the appropriate boot command: `bootz` for zImage, `booti` for Image, or `bootm` for FIT and legacy uImage formats.

The device tree blob (.dtb file) describes the hardware on the board — what peripherals exist, where they are in the address space, what interrupts they use, and how they are connected. U-Boot loads this into a separate DRAM address and passes its location to the kernel as an argument. The kernel uses the device tree to discover and configure hardware at boot time instead of having board-specific code compiled in. This is covered in depth in [Device Tree & Hardware Description]({{< relref "device-tree-and-hardware-description" >}}). Getting the right .dtb for your board is critical — the wrong one means the kernel will not find its peripherals, or worse, will try to access hardware that does not exist at the addresses described, leading to hangs or crashes.

The initramfs (initial RAM filesystem) is an optional compressed filesystem image loaded into DRAM alongside the kernel. When present, the kernel mounts it as the initial root filesystem before the real root filesystem is available. This is useful — and sometimes essential — when the kernel needs to load modules or run scripts before it can access the real root device. For example, if the root filesystem is on an eMMC that requires a specific driver not compiled into the kernel, the initramfs provides a minimal environment where that driver can be loaded. On many embedded systems, the kernel is configured with all necessary drivers built in (not as modules), and the initramfs is not used. But on platforms with more complex storage configurations, or when using full distributions like Debian on an SBC, the initramfs is required.

The actual handoff from U-Boot to the kernel is a point of no return. U-Boot writes the kernel command line and device tree address into the correct ARM registers (or memory locations, depending on the architecture), disables interrupts, and jumps to the kernel entry point. At this moment, U-Boot is gone — its memory will be reclaimed, and if the kernel fails, there is no falling back to the bootloader. This is why getting the load addresses, device tree, and command line right in U-Boot is so important: once the kernel starts, the bootloader cannot help you anymore.

## The Kernel Startup Sequence

The kernel takes over from the bootloader with the processor in a specific state: MMU off, caches off (or in a known state), interrupts disabled, and a pointer to the device tree in a register. The first thing it does is set up the MMU and enable virtual memory — the transition from physical addressing (which the bootloader used) to virtual addressing (which everything from here on out will use). This is a delicate moment. If the page tables are wrong, the system crashes immediately with no output.

After enabling the MMU, the kernel initializes its core subsystems in a specific order: memory management (page allocator, slab allocator, vmalloc), the scheduler, timers, and interrupt handling. It then begins probing devices described in the device tree. Device probing is where kernel drivers match against device tree nodes — the kernel walks the device tree, finds nodes with `compatible` strings that match registered drivers, and calls each driver's probe function. This is when UARTs, I2C buses, SPI controllers, Ethernet interfaces, and storage controllers come to life. If the serial console driver probes successfully, you start seeing kernel boot messages (the familiar `dmesg` output with timestamps).

The kernel then mounts the root filesystem. The location is specified by the `root=` parameter on the kernel command line, which U-Boot passed during the handoff. A typical value is `root=/dev/mmcblk0p2` (second partition on the first MMC device) or `root=/dev/sda1`. The kernel needs the correct storage driver and filesystem driver compiled in (or available in the initramfs) to mount root. If either is missing, the kernel panics with "VFS: Unable to mount root fs" — one of the most common boot failures and, fortunately, one of the most recognizable.

Once root is mounted, the kernel launches the init process — PID 1, the ancestor of all user-space processes. On most embedded Linux systems this is either systemd (common on Debian-based distributions, including Raspberry Pi OS), BusyBox init (common on buildroot and Yocto minimal images), or SysVinit (legacy, but still seen on older systems). Init reads its configuration, starts services, mounts additional filesystems (`/proc`, `/sys`, `/dev` via devtmpfs), configures networking, and eventually presents a login prompt on the serial console or launches the target application.

The total time from power-on to a shell prompt depends enormously on the platform and configuration. A minimal Buildroot system on a fast SoC can boot in under 5 seconds. A full Debian installation on a Raspberry Pi with systemd and many services takes 15-30 seconds. Most of the time is spent in the kernel (probing devices, especially slow ones like USB) and init (starting services). If boot time matters — and in many embedded products it does — there are optimization techniques: removing unnecessary kernel drivers, using a minimal init system, deferring service startup, and pre-initializing device tree overlays. But even an optimized MPU boot is orders of magnitude slower than an MCU, which is one of the key tradeoffs of choosing this architecture.

## Gotchas

- **Boot ROM bugs exist and cannot be fixed.** Because the boot ROM is mask ROM, errata in it persist for the lifetime of the silicon revision. TI's AM335x had boot ROM issues with certain SD card timing modes. Allwinner SoCs have had FEL mode quirks. The only workarounds are software mitigations in the bootloader or choosing a different boot source. Check the errata sheet before committing to a SoC

- **Bricking is real if you corrupt the bootloader.** If the bootloader partition on eMMC is corrupted and the SoC does not have a fallback boot mode (or you do not know how to use it), the board cannot boot. Always ensure you have a recovery path — USB boot, UART boot, or the ability to boot from SD card even if eMMC is the primary boot device. On production boards, consider A/B bootloader partitions or a write-protected fallback bootloader

- **U-Boot environment corruption can prevent boot.** The U-Boot environment is typically stored in raw flash at a fixed offset or in a small partition. If it gets corrupted (partial write, power loss during save), U-Boot may fail to parse it and either refuse to boot or use compiled-in defaults that may not match your board. Some U-Boot configurations support redundant environments (two copies, with a validity flag). Even so, it is worth knowing where your environment is stored and how to reset it

- **The serial console is your single most important debug tool.** UART is almost always the first peripheral the boot ROM initializes, and every stage of the boot chain outputs messages to it. Without a serial console, you are debugging blind — you cannot tell whether the system is stuck in the boot ROM, in U-Boot, in the kernel, or in user-space init. A USB-to-UART adapter ($5-10) and a terminal emulator are non-negotiable tools for embedded Linux work. Always connect it before powering the board

- **Boot device order causes surprises.** Some SoCs try boot devices in a fixed order — for example, SD card before eMMC. If you leave a development SD card in the slot, the board boots from it instead of the eMMC image you just flashed. This is a rite-of-passage debugging session: "the new image was flashed but the system is still running the old one." Check the boot source selection mechanism for your SoC and remove any media you do not intend to boot from

- **Kernel panic at boot usually means a bad device tree or missing root filesystem.** A kernel panic with "Unable to mount root fs" means either the `root=` command line is wrong, the storage driver is missing, or the filesystem driver is missing. A kernel panic with no output at all (or garbage characters on the console) often means the wrong device tree was loaded — the kernel tried to initialize a UART that does not exist at the address the device tree specified

- **Initramfs is not always optional.** If the kernel needs to load modules before it can access the root filesystem (common when storage drivers are built as modules rather than compiled in), an initramfs is required. A system that boots fine with one kernel configuration may fail with another if the storage driver was moved from built-in to module. When debugging "Unable to mount root fs," check whether the kernel config expects an initramfs that is not being loaded
