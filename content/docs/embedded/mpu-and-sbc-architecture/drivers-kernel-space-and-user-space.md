---
title: "Drivers, Kernel Space & User Space"
weight: 60
---

# Drivers, Kernel Space & User Space

On an MCU, all code runs at the same privilege level with full access to every register and memory address. On an MPU running Linux, code is divided into two worlds: kernel space (privileged, full hardware access) and user space (restricted, hardware access only through the kernel). This split is what makes a multi-user, multi-process operating system possible -- and it is where most of the confusion lives when coming from bare-metal embedded work.

## The Privilege Split

ARM defines a set of Exception Levels that determine what code is allowed to do. EL0 is user mode -- where application code runs. EL1 is the kernel -- where the OS runs with full control of the hardware. EL2 is the hypervisor level, used when running virtual machines. EL3 is the secure monitor, used for Arm TrustZone transitions. For most embedded Linux work, the only two that matter are EL0 and EL1. The hypervisor and secure monitor levels exist on many SoCs but are not something you interact with unless you are running a hypervisor or implementing secure boot.

What can be surprising at first is how absolute the split is. Code running at EL0 cannot execute privileged instructions -- period. It cannot touch MMU configuration registers, it cannot disable interrupts, and it cannot write to I/O memory that has not been explicitly mapped into its address space. Attempting any of these causes the CPU to trap to the kernel. The trap is not optional and cannot be bypassed by clever coding. The hardware enforces it. This is fundamentally different from an MCU, where any code can write to any address at any time, and the only thing stopping you is discipline. See [MMU, Virtual Memory & Address Spaces]({{< relref "mmu-virtual-memory-and-address-spaces" >}}) for how the MMU enforces address space separation at the hardware level.

The defined interface between user space and kernel space is the system call, or syscall. When user-space code needs something that requires privilege -- opening a file, reading from a device, allocating memory, sending a network packet -- it invokes a syscall. The mechanism is an instruction (`svc` on ARM) that causes a controlled transition from EL0 to EL1. The kernel's syscall handler inspects the request, validates the arguments (is this file descriptor valid? does this process have permission to access this device?), performs the operation, and returns the result. The CPU then transitions back to EL0 and the user-space code continues.

The cost of a syscall is not trivial. The transition involves saving and restoring register state, switching stack pointers, and potentially flushing caches or TLB entries. On a Cortex-A processor, a minimal syscall round-trip takes hundreds of nanoseconds to a few microseconds. This matters when you are thinking about user-space I/O: every read, write, or ioctl call to a device is a syscall, and if you are doing thousands of them per second, the overhead adds up. On an MCU, writing to a peripheral register is a single store instruction -- a few nanoseconds. On an MPU through the kernel, that same conceptual operation takes orders of magnitude longer because of the privilege transition machinery.

One thing worth internalizing: running as root does not make your code kernel-space code. Root is a user-space concept -- it means the kernel will grant most permission checks, but your code still runs at EL0, still goes through syscalls, and still cannot touch hardware directly. A common misconception is that `sudo` somehow gives a program direct hardware access. It does not. It gives the kernel permission to grant more requests, but the code itself is still in user space.

## Kernel Modules and Device Drivers

A device driver is kernel code that manages a specific piece of hardware. It does what firmware does on an MCU: configures registers, handles interrupts, moves data. But instead of running as standalone code with full control, it runs within the kernel's framework -- registering with the device model, exposing interfaces through the Virtual File System, and respecting kernel locking and memory allocation rules. The driver is simultaneously more powerful (it can do anything the kernel can do) and more constrained (it must follow the kernel's conventions or risk crashing the entire system).

Drivers can be compiled directly into the kernel image (built-in) or compiled as loadable modules (`.ko` files) that can be inserted and removed at runtime. Built-in drivers are always available from boot and have no load-time overhead, but they increase the kernel image size and cannot be updated without rebuilding the kernel. Modules are more flexible: you load them with `insmod` (direct load) or `modprobe` (which also loads dependencies), and unload them with `rmmod`. On embedded systems with a well-defined hardware configuration, building drivers as built-in is common -- there is no need for the flexibility of modules when the hardware will never change. On SBCs running a general-purpose distribution, most drivers ship as modules because the distribution must support many different hardware configurations.

The relationship between the device tree and the driver is central to how modern embedded Linux works. The device tree describes what hardware exists on the board -- which buses, which peripherals, at what addresses, with what interrupt lines. The driver registers with the kernel saying "I know how to drive devices with these `compatible` strings." When the kernel parses the device tree at boot (or when a device tree overlay is applied at runtime), it matches device tree nodes to drivers by their `compatible` property. If a match is found, the kernel calls the driver's `probe` function, passing it information from the device tree node. The driver then initializes the hardware and makes it available to the rest of the system. This is covered in detail in [Device Tree & Hardware Description]({{< relref "device-tree-and-hardware-description" >}}).

A useful mental model is that a driver has three relationships it must manage. First, its relationship with the hardware: register addresses, interrupt lines, DMA channels, clock and power domains. Second, its relationship with the kernel's subsystem frameworks: a network driver registers with the networking subsystem, a block driver with the block subsystem, a character driver with the VFS. Third, its relationship with user space: exposing device files in `/dev/`, attributes in `/sys/`, or interfaces through netlink or other mechanisms. Getting any one of these wrong produces a driver that either does not work, crashes the kernel, or is unusable from user space.

Writing a kernel driver is a qualitatively different experience from writing user-space code. Memory allocation can fail and you must handle that (no lazy overcommit in kernel space). Sleeping in the wrong context (interrupt handler, while holding a spinlock) causes deadlocks or panics. A null pointer dereference does not produce a friendly segfault -- it produces a kernel oops or panic that may take down the entire system. There is no standard C library (no printf, no malloc -- you use `printk` and `kmalloc`). Debugging is harder because printf-style debugging requires `dmesg` and because bugs can corrupt kernel memory, causing symptoms far from the actual defect. All of this is why the standard advice is to avoid writing kernel drivers when user-space alternatives exist.

## User Space Access Patterns

User-space code accesses hardware through interfaces the kernel provides. The most common is the device file in `/dev/`. Character devices (like `/dev/ttyS0` for a UART, or `/dev/spidev0.0` for SPI) support `open`, `read`, `write`, `close`, and `ioctl` operations. Block devices (like `/dev/mmcblk0` for an SD card) add block-level operations and can have filesystems mounted on them. When you open a device file and call read or write, the kernel routes those calls to the corresponding driver's functions. From user space, it looks like file I/O. Under the hood, the driver is talking to hardware.

The `sysfs` filesystem, mounted at `/sys/`, is the kernel's way of exposing device attributes as simple files. Each device in the system gets a directory under `/sys/`, and the driver can create attribute files there -- readable, writable, or both. For example, an LED driver might expose `/sys/class/leds/led0/brightness` as a writable file: echo a number to it, and the LED changes brightness. A PWM driver exposes `/sys/class/pwm/pwmchip0/pwm0/duty_cycle` and `/sys/class/pwm/pwmchip0/pwm0/period`. GPIO pins used to be controlled through `/sys/class/gpio/` (deprecated now, but still widely seen in tutorials). The beauty of sysfs is that shell scripts and simple programs can control hardware without any driver-specific libraries -- just read and write to files. The downside is performance: each read or write involves opening a file, a syscall, string formatting or parsing, and closing the file. For high-frequency operations, this overhead is unacceptable.

The `procfs` filesystem (`/proc/`) is older and originally designed for process information, but it has accumulated various kernel interfaces over the years. `/proc/interrupts` shows interrupt counts per CPU. `/proc/iomem` shows physical memory regions mapped to devices. `/proc/device-tree/` (on some systems) exposes the device tree as a filesystem. For hardware access, `sysfs` has largely replaced `procfs`, but `procfs` remains important for system introspection and debugging.

The `ioctl` (I/O control) system call deserves special attention because it is the escape hatch for device-specific operations that do not fit the read/write model. Each driver defines its own set of ioctl command numbers, and user-space code calls `ioctl(fd, command, argument)` to invoke them. For SPI, ioctl configures clock speed, mode, and bits-per-word, and performs full-duplex transfers. For I2C, ioctl sets the slave address. For video devices (V4L2), ioctl handles format negotiation, buffer management, and streaming control. Ioctl is powerful but problematic: the commands are untyped (just integers and void pointers), the documentation for each driver's ioctl interface varies from excellent to nonexistent, and getting the argument structures wrong causes silent failures or kernel crashes in poorly written drivers. Ioctl is effectively the place where the elegance of the Unix "everything is a file" model breaks down and the code is back to speaking a hardware-specific protocol.

The `mmap()` system call lets user-space code map device memory directly into its address space. The kernel sets up the MMU translation so that accesses to a range of virtual addresses go to the device's physical registers or memory. This is how framebuffer devices work: the application mmaps the framebuffer and writes pixel data directly. It is how DMA buffers are shared with user space. And it is how `/dev/mem` works -- mmapping ranges of physical memory into user space. The mmap path avoids per-access syscall overhead, which makes it attractive for high-bandwidth devices, but it requires the driver (or the kernel) to set up the mapping correctly, with appropriate cache attributes and access permissions.

## GPIO, SPI, I2C from User Space

On an MCU, you toggle a GPIO pin by writing to a register. On an MPU running Linux, the equivalent operation goes through a kernel subsystem and a user-space interface. This feels heavyweight at first, but the interfaces are well designed and appropriate for many use cases.

`libgpiod` is the modern interface for GPIO access from user space. It replaces the older sysfs GPIO interface (`/sys/class/gpio/export`, `/sys/class/gpio/gpioN/direction`, etc.), which is deprecated and will eventually be removed. The libgpiod approach is based on character devices (`/dev/gpiochipN`) and provides both command-line tools and a C library. `gpiodetect` lists available GPIO controllers. `gpioinfo` shows the lines on each controller and their current configuration. `gpioget` reads a pin. `gpioset` writes a pin. `gpiomon` monitors a pin for edges (rising, falling, or both) -- this is the user-space equivalent of a GPIO interrupt, and it uses the kernel's interrupt infrastructure under the hood, so edge detection is reliable even though the notification arrives in user space. The C library (`libgpiod`) provides the same functionality programmatically, with proper support for requesting lines, setting biases (pull-up, pull-down), and handling events. A notable improvement is that libgpiod made GPIO naming explicit -- you reference pins by chip and line number (or by name, if the device tree defines names), which avoids the confusing global GPIO numbering scheme that the sysfs interface used.

SPI access from user space uses the `spidev` driver. When the device tree describes an SPI device with `compatible = "spidev"`, the kernel creates a `/dev/spidevX.Y` device file (X = bus number, Y = chip select). User-space code opens this file and uses ioctl to configure transfer parameters (clock speed, SPI mode 0/1/2/3, bits per word, CS polarity) and to perform transfers. A transfer is a simultaneous send-and-receive: you fill a buffer with bytes to transmit, pass it via ioctl, and get back the bytes that were simultaneously received (because SPI is full-duplex). The spidev interface works well for prototyping and for slow peripherals -- sensors, DACs, small displays. The limitation is that every transfer involves a syscall and a context switch, so throughput for high-speed, high-frequency SPI devices is significantly lower than what a kernel driver achieves.

I2C access from user space uses the `i2c-dev` driver, which exposes each I2C bus as `/dev/i2c-X`. The `i2c-tools` package provides essential command-line utilities: `i2cdetect` scans the bus and shows which addresses respond (invaluable for verifying that a device is wired correctly and powered), `i2cget` reads a register, `i2cset` writes a register, and `i2cdump` reads a range of registers. For programmatic access, you open `/dev/i2c-X`, use ioctl to set the slave address, then use read/write or SMBus ioctl commands to communicate. This is how most sensor-reading scripts work on Raspberry Pi and similar boards. The performance is fine for I2C's typical use case -- reading a temperature sensor at 1 Hz does not need kernel-driver performance.

When user-space access is appropriate: prototyping and development (where fast iteration matters more than performance), slow peripherals (sensors polled at low rates, LEDs, simple actuators), one-off scripts and debugging tools. See [GPIO]({{< relref "/docs/embedded/peripherals-and-io/gpio" >}}) and [SPI & I2C]({{< relref "/docs/embedded/communication-interfaces/spi-and-i2c" >}}) for how these interfaces work at the MCU register level.

## When You Need a Kernel Driver

User-space access is convenient but has hard limits. Understanding where those limits are saves time -- either you know up front that you need a kernel driver, or you avoid writing one unnecessarily.

Interrupt handling is the most fundamental limit. User-space code cannot register interrupt handlers. When a peripheral asserts an interrupt line, only a kernel interrupt handler can respond. The kernel can route the notification to user space (via poll/select on a device file, or through UIO), but the initial response -- acknowledging the interrupt, reading the status register, clearing the interrupt flag -- must happen in kernel space. For peripherals where interrupt latency matters (a data-ready signal from a high-speed ADC, a packet-received interrupt from an Ethernet controller), the kernel driver must handle the time-critical work before anything reaches user space. The latency from interrupt to user-space notification is typically tens to hundreds of microseconds, which is fine for many applications but fatal for others.

DMA is another area where user space cannot operate directly. Setting up a DMA transfer requires configuring the DMA controller with physical addresses (not virtual), managing cache coherency (ensuring the CPU and the DMA controller see consistent data), and handling completion interrupts. Only the kernel has the privilege and the mechanisms to do this safely. The kernel's DMA API handles the translation between virtual and physical addresses, manages cache operations, and provides scatter-gather support for non-contiguous buffers. A user-space program that needs DMA performance must use a kernel driver that sets up the transfers and either copies data to user space or shares DMA buffers via mmap.

High-frequency I/O runs into syscall overhead. Toggling a GPIO from user space involves a syscall for each transition -- open (once), then write or ioctl for each toggle. On a typical Cortex-A processor running Linux, this limits GPIO toggle rates to somewhere around 100 kHz, give or take depending on the specific SoC, kernel configuration, and system load. A kernel driver can toggle GPIO at the hardware's maximum rate because it writes directly to the register with no syscall overhead. Similarly, bit-banging protocols (like one-wire or custom serial protocols) from user space is impractical because the timing cannot be guaranteed -- the scheduler can preempt your process at any point, inserting milliseconds of latency into what should be a microsecond-level timing sequence.

Atomic multi-register operations are a subtler problem. Some peripherals require a specific sequence of register writes with precise timing -- for example, writing a configuration register and then a trigger register within a certain number of clock cycles, or reading a multi-byte value where the hardware latches all bytes when the first byte is read. From user space through sysfs or ioctl, each operation is a separate syscall, and the kernel (or the scheduler) can interleave other work between them. A kernel driver can perform the entire sequence atomically, with interrupts disabled if necessary.

Before writing a custom kernel driver, always check whether one already exists. The Linux kernel has drivers for thousands of devices, and many are configurable through the device tree. A sensor that seems to need custom code might already be supported by an IIO (Industrial I/O) driver that exposes readings through sysfs. A display controller might be supported by a DRM/KMS driver. An audio codec might have an ALSA driver. Searching the kernel source tree (`drivers/` directory) for the chip's name or the manufacturer's name is a good starting point. The kernel mailing list archives and device tree binding documentation (`Documentation/devicetree/bindings/`) are also valuable. Writing a kernel driver when one already exists is a waste of effort and likely to produce something buggier than the upstream version.

## Gotchas

- **Sysfs GPIO is deprecated but still everywhere in tutorials.** The `/sys/class/gpio/` interface was deprecated in favor of the character device interface used by `libgpiod`. Old tutorials, Stack Overflow answers, and even some vendor documentation still use it. Code written against sysfs GPIO will continue to work for now, but it lacks features (named lines, proper event handling, bias configuration) and will eventually be removed. Use `libgpiod` for any new work

- **User-space SPI and I2C are slow compared to kernel drivers.** Every transaction involves at least one syscall, and the overhead is significant at high data rates. A kernel SPI driver can sustain multi-megabit transfers using DMA, while spidev is limited by the syscall-per-transfer model. For sensors read once per second, this does not matter. For a display updated at 30 fps, it absolutely does

- **ioctl numbers are not standardized across drivers.** Each driver defines its own ioctl command numbers and argument structures. There is no single header file you can include that covers all devices. You need the specific driver's header (often in the kernel source under `include/uapi/linux/`) to know what ioctls it supports and what data structures to pass. Getting the ioctl number or structure layout wrong produces silent failures or kernel crashes in poorly written drivers

- **Loading a kernel module can crash the system.** Kernel modules run with full kernel privilege. A bug in a module -- null pointer dereference, use-after-free, incorrect locking -- can panic the kernel or corrupt memory. There is no memory protection between modules and the rest of the kernel. On a development system, this means a reboot. On a deployed system with no serial console and no watchdog, it means a field trip. Always test modules on a development board with serial console attached before deploying

- **`/dev/mem` bypasses all protections and is dangerous in production.** Opening `/dev/mem` and mmapping physical addresses gives user-space code raw access to physical memory -- including kernel memory, DMA buffers, and hardware registers the kernel thinks it owns exclusively. It is enormously useful for quick experiments and debugging (peek at a register without writing a driver), but it is a security hole and a reliability hazard in production. Most modern distributions restrict `/dev/mem` access via the `CONFIG_STRICT_DEVMEM` kernel option, which limits mmap to non-RAM regions. If you need it and it is blocked, that is the kernel telling you to write a proper driver

- **Running as root does not make your code kernel-space code.** Root is a user-space privilege concept. A root process still runs at EL0, still goes through syscalls, and still cannot execute privileged instructions. Running an I/O program as root gives it permission to open `/dev/mem` or device files, but the code itself is still in user space with all the associated overhead and limitations. Confused forum posts sometimes appear where someone expects `sudo` to eliminate syscall latency. It does not

- **Not all kernel drivers support device tree binding.** Older drivers -- especially those written before the device tree became standard on ARM (roughly pre-2012) -- use platform data structures or hardcoded addresses. These drivers may still work but require board-specific kernel patches instead of a device tree entry. When evaluating whether a chip is supported on embedded Linux, check not just that a driver exists but that it has device tree binding documentation (`Documentation/devicetree/bindings/`). A driver without device tree support will require more porting effort than one with it
