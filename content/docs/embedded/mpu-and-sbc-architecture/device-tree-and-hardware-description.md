---
title: "Device Tree & Hardware Description"
weight: 50
---

# Device Tree & Hardware Description

On an MCU, firmware knows what peripherals exist because the datasheet says so and the memory map is fixed. On an MPU running Linux, the kernel needs to be told what hardware is present -- which I2C buses exist, what GPIO controller is at what address, how interrupts are wired. The device tree is how that description is provided: a data structure that tells the kernel what the board looks like, without recompiling the kernel itself.

## The Problem: Hardware Is Not Discoverable

Some buses have built-in discovery mechanisms. PCI devices carry a configuration space with vendor ID, device ID, class code, and a list of resources they need. USB devices respond to enumeration with descriptors that identify the manufacturer, product, and supported interfaces. When you plug in a USB keyboard, the host controller queries the device, the kernel matches the descriptors to a driver, and the device just works. No one had to tell the kernel in advance that a keyboard would be attached.

SoC peripherals have no such mechanism. An I2C controller mapped at address 0x44E0B000 on a TI AM335x does not broadcast its existence. A GPIO controller at 0x4804C000 has no way to announce itself, describe its register layout, or declare how many pins it manages. These blocks sit silently on the internal bus, waiting for software that already knows they are there. The information exists in the SoC's technical reference manual, but someone has to encode that knowledge into a form the kernel can consume.

Before device trees, Linux solved this problem with board files -- C source files compiled directly into the kernel, one per supported board. A board file for the BeagleBone would contain structure initializers describing every peripheral: this I2C controller at this address, using this interrupt line, with this clock source. The approach worked, but it scaled horribly. The ARM kernel tree accumulated hundreds of board files, each requiring kernel recompilation for even trivial changes like enabling an extra SPI bus. Adding a new board meant patching the kernel, which discouraged hardware experimentation and created a maintenance nightmare.

Device tree moved the hardware description out of the kernel into a separate data file. The kernel became generic -- one kernel binary can boot on many different boards, as long as each board supplies a device tree blob (DTB) describing its hardware. The concept was not new; PowerPC and OpenFirmware had used device trees for years. ARM adopted the mechanism around 2011-2012, and it was the single biggest cleanup in the ARM kernel's history. The board files were gradually deleted, replaced by .dts files maintained alongside the kernel but compiled separately. See [Boot Chain: ROM to Bootloader to Kernel]({{< relref "boot-chain" >}}) for how the DTB gets loaded and passed to the kernel during the boot process.

The practical impact of this shift is significant even if you never write a device tree from scratch. When you buy a Raspberry Pi or a BeagleBone, the vendor supplies a pre-built DTB that matches the board's hardware. When you add a peripheral HAT or cape, you apply an overlay that patches the DTB. When something does not work, understanding that the device tree is the kernel's only source of hardware knowledge tells you where to look. The kernel does not probe the bus to see what is there -- it reads the device tree and trusts it.

## Device Tree Syntax and Structure

The device tree source format (.dts) looks superficially like JSON crossed with C. It is a hierarchical tree of nodes, where each node represents a device, a bus, or a logical grouping. Nodes contain properties -- key-value pairs that describe the hardware. The format is human-readable (barely), and once you get past the initial syntax shock, it follows a consistent logic.

The most important property in any device node is `compatible`. This is a string (or list of strings) that tells the kernel which driver to use for this device. When the kernel walks the device tree at boot, it matches each node's `compatible` string against the `of_match_table` in registered drivers. If a match is found, the kernel calls that driver's probe function, passing it a reference to the node so the driver can read the rest of the properties. For example, `compatible = "brcm,bcm2711-gpio"` tells the kernel to look for the BCM2711 GPIO driver. The convention is `"vendor,device"` -- vendor prefix first, then the specific part.

Other common properties include `reg`, which specifies the register address and size for the device; `interrupts`, which describes the interrupt lines the device uses; `clocks`, which references clock source nodes; and `status`, which is either `"okay"` (device is present and should be probed) or `"disabled"` (device exists in the SoC but is not used on this board). The `reg` property is interpreted relative to the parent node's address space -- a device under an I2C bus node uses the I2C slave address, not a memory-mapped register address.

A simple device node looks like this:

```dts
gpio: gpio@7e200000 {
    compatible = "brcm,bcm2835-gpio";
    reg = <0x7e200000 0xb4>;
    interrupts = <2 17>, <2 18>;
    gpio-controller;
    #gpio-cells = <2>;
    status = "okay";
};
```

The node name (`gpio@7e200000`) includes the unit address for uniqueness. The label (`gpio:`) allows other nodes to reference this one by name. The `gpio-controller` property (with no value) marks this as a GPIO provider, and `#gpio-cells = <2>` tells consumers that references to this controller need two cells (pin number and flags).

Device trees use include files (.dtsi) to separate SoC-level definitions from board-level customizations. A .dtsi file for the BCM2711 SoC defines all the peripherals the chip contains, with most set to `status = "disabled"`. A board-level .dts file includes the SoC .dtsi and then overrides specific nodes to enable the peripherals that are actually wired up on that board, set pin assignments, and configure board-specific parameters. This layering means the SoC description is written once and reused across every board that uses that chip.

Cross-references between nodes use phandles. If a device needs to reference its clock source, it includes a property like `clocks = <&clk_gpio>;` where `&clk_gpio` resolves to the phandle of the clock node labeled `clk_gpio`. This mechanism allows the device tree to express dependency relationships -- the kernel knows that a UART depends on a specific clock and can ensure the clock is enabled before probing the UART. Phandle resolution is one of the things that makes the device tree more than just a flat configuration file; it encodes a graph of hardware relationships.

A point worth internalizing is that the `compatible` property often contains a list of strings, from most specific to most generic: `compatible = "brcm,bcm2711-uart0", "arm,pl011", "arm,primecell";`. The kernel tries to match drivers against each string in order. If no driver specifically handles the BCM2711 UART, it falls back to the generic PL011 driver. This fallback mechanism is how a single generic driver can support dozens of SoC variants -- the device tree encodes the specificity, and the kernel picks the best available match.

## Device Tree Overlays

The base device tree describes the board as it ships from the factory: which peripherals are enabled, how pins are configured, what the default state looks like. But hardware is not always static. You add a HAT to a Raspberry Pi. You plug a cape onto a BeagleBone. You wire an I2C sensor to the expansion header and need the kernel to know about it. Overlays are the mechanism for modifying the device tree at runtime without replacing the entire DTB.

An overlay is a small device tree fragment that specifies a target node in the base tree and a set of changes to apply. It can add new child nodes, modify existing properties, or change the `status` of a peripheral from `"disabled"` to `"okay"`. The overlay format wraps these changes in a `fragment` structure that identifies the target by path or by label. When applied, the overlay patches the base DTB in memory, and the kernel sees the result as if it had been compiled into the original tree.

Raspberry Pi uses overlays extensively. The `config.txt` file on the boot partition accepts `dtoverlay=` directives that load overlay files from the `/boot/overlays/` directory. Enabling the I2S audio interface, adding an SPI-connected display, or configuring a GPIO-connected IR receiver -- these are all done through overlays. The Pi's firmware (which acts as the bootloader) applies the overlays to the DTB before passing it to the kernel, so by the time Linux starts, the device tree already reflects the overlay changes. This is why overlay changes in `config.txt` require a reboot -- the firmware processes them during boot, not while the system is running.

BeagleBone capes use a similar concept but with a different mechanism. Historically, BeagleBone used a runtime overlay system that could apply overlays after boot through a capemgr (cape manager) interface. This was convenient but fragile -- applying overlays to a running kernel is complex because drivers may need to be unloaded and reloaded, and pin mux changes on a live system risk electrical conflicts. The current recommendation on most platforms is to apply overlays at boot time through the bootloader (U-Boot can merge overlays into the DTB) rather than at runtime.

A common source of confusion is the interaction between overlays and pin muxing. An overlay that enables an SPI peripheral also needs to configure the pins for SPI function. If those pins are already assigned to another function by the base device tree (say, configured as GPIOs), the overlay must override the pin mux settings. If two overlays try to claim the same pins, the result depends on load order, and the conflict may not produce an obvious error. The pin mux just ends up in whatever state the last overlay set, which can mean one peripheral works and the other silently fails -- or worse, two drivers try to drive the same pin simultaneously.

Writing overlays from scratch is also more finicky than editing a full .dts file. The overlay format requires a specific wrapper structure with `/dts-v1/; /plugin/;` at the top, and the fragment targeting syntax differs between older and newer dtc versions. The Raspberry Pi overlay documentation is the most practical starting point -- the examples are real, working overlays that can be modified for custom hardware. The kernel documentation on overlays is correct but abstract enough to be confusing on first read.

## Bindings: Connecting Hardware to Drivers

The device tree describes hardware. Drivers implement control logic. Bindings are the contract between them -- a formal specification of what properties a device tree node must contain for a given driver to work correctly. Without bindings, writing a device tree node would be guesswork: what properties does this driver expect? What format should the `reg` property be in? How many interrupt cells are needed?

Binding documents live in the kernel source tree under `Documentation/devicetree/bindings/`, organized by subsystem (gpio, i2c, spi, net, etc.). Historically, bindings were written in free-form text, which led to inconsistencies and made automated validation impossible. The kernel community has been migrating to YAML-based binding schemas (dt-schema) that can be machine-validated. A YAML binding specifies required and optional properties, their types, allowed values, and relationships between properties. The `make dt_binding_check` target runs schema validation against the bindings, and `make dtbs_check` validates compiled device trees against the schemas.

The `compatible` string is the linchpin of the entire system. When the kernel boots, it iterates over the device tree nodes. For each node with a `compatible` property, the kernel searches its list of registered drivers for a matching `of_match_table` entry. If a match is found, the kernel calls the driver's `probe` function. The probe function reads properties from the device tree node -- register addresses, interrupt numbers, clock references, configuration parameters -- and initializes the hardware. This process happens in dependency order: if a device node references a clock or a regulator that has not been probed yet, the kernel defers the probe and retries later.

The critical insight is understanding what happens when things go wrong in this matching process. If a node's `compatible` string does not match any loaded driver, the kernel silently ignores it. There is no warning in `dmesg`, no error message, nothing. The device simply does not exist from the kernel's perspective. This is by design -- a generic kernel image might encounter device tree nodes for hardware it does not have drivers for -- but it makes debugging painful. If you add a device tree node and the corresponding device does not appear in `/dev` or `/sys`, the first thing to check is whether the `compatible` string exactly matches what the driver registers. A single typo means no match.

The binding system also enforces a separation of concerns that is often underappreciated. The device tree describes what hardware exists and how it is connected. It does not contain policy -- no baud rates, no application-level configuration, no behavioral parameters beyond what the hardware needs for initialization. This keeps the device tree focused on hardware description and leaves policy to user-space configuration and driver module parameters. Some drivers blur this line (a few accept hints about default operating modes through device tree properties), but the principle is that the device tree answers "what is here?" not "how should it be used?"

The binding documentation is invaluable for understanding what a driver actually needs. Reading a YAML binding file for, say, a GPIO expander tells you exactly which properties are required (`compatible`, `reg`, `#gpio-cells`), which are optional (`interrupt-controller`, `reset-gpios`), and what values are legal. It is a better starting point than the driver source code, which mixes hardware description parsing with initialization logic and error handling. The `make dtbs_check` workflow catches most property errors before you ever boot the board, which saves the painful reboot-and-debug cycle.

## Practical Device Tree Workflow

The typical workflow starts with wanting to change something: enable a peripheral, add an external device, change a pin assignment. The first step is finding the right file to edit. For SoC-level changes, the .dtsi file in `arch/arm64/boot/dts/` (or `arch/arm/boot/dts/` for 32-bit) contains the base definitions. For board-level changes, the corresponding .dts file includes the SoC .dtsi and adds board-specific overrides. For one-off changes, writing an overlay is usually the least invasive approach.

The device tree compiler, `dtc`, converts between the human-readable .dts source and the binary .dtb format the kernel consumes. In practice, you rarely invoke `dtc` directly. The kernel build system handles compilation: `make dtbs` compiles all device tree sources for the configured architecture, and `make ARCH=arm64 broadcom/bcm2711-rpi-4-b.dtb` compiles a specific board's DTB. The build system also handles the .dtsi include mechanism, which `dtc` alone does not support (it requires the C preprocessor for includes).

When something does not work -- a device does not appear, a driver fails to probe, a peripheral misbehaves -- the debugging process follows a predictable pattern. The first tool is `/proc/device-tree/` (symlinked to `/sys/firmware/devicetree/base/` on most systems). This virtual filesystem exposes the live device tree as the kernel sees it, after all overlays have been applied. You can navigate it like a directory tree, reading property values from files. If the node you expect is missing from `/proc/device-tree/`, the problem is in the device tree source or the overlay application. If the node exists but the device is not functional, the problem is likely in the driver or the property values.

The second tool is `dmesg`. Driver probe failures are logged here, often with specific error messages about missing clocks, failed register reads, or resource conflicts. Searching `dmesg` for the driver name or the `compatible` string often reveals why a probe failed. The `-EPROBE_DEFER` pattern is common -- it means the driver tried to probe but a dependency (clock, regulator, GPIO controller) was not ready yet. The kernel retries deferred probes, so `-EPROBE_DEFER` is usually transient. If the final state is still a failed probe, the dependency itself may be broken.

For offline analysis, `fdtdump` decompiles a .dtb file back to readable text, which is useful for inspecting what the bootloader actually passed to the kernel (the file on disk might differ from what is in memory if overlays were applied). The `dtdiff` tool compares two .dtb files, which is helpful when you are trying to understand what an overlay changed. The reliable debugging loop is: check the live tree in `/proc/device-tree/`, check `dmesg` for probe errors, fix the source, recompile, reboot, repeat. It is not fast, but it is reliable.

One practical tip worth noting: when working with Raspberry Pi, the `vcdbg log msg` command shows the firmware's device tree processing messages, including overlay application. If an overlay failed to load (wrong format, missing target node), the kernel's `dmesg` will not tell you -- the failure happened in the firmware before the kernel started. The Pi firmware log is the only place to see those errors.

## Gotchas

- **Wrong `compatible` string means no driver binds, silently** -- There is no error, no warning, nothing in `dmesg`. The node sits in the device tree and no driver claims it. The device simply does not exist from the kernel's perspective. A single typo in the compatible string is enough. Always verify the exact string against the driver source's `of_match_table`
- **Pin mux conflicts are not always caught at boot** -- Two device tree nodes claiming the same pin can result in electrical contention: two drivers trying to drive the same physical pin in different directions. Some pin controllers detect conflicts and refuse the second claim, but many do not. The result can be damaged GPIO pins or confusing signal integrity problems
- **`status = "disabled"` is the default for many SoC-level nodes** -- The .dtsi file for the SoC defines all peripherals but typically sets most to `status = "disabled"`. The board .dts must explicitly set `status = "okay"` for each peripheral that is actually used. Forgetting this is one of the most common reasons a device tree node exists but nothing happens
- **Overlay load order matters** -- Later overlays override earlier ones. If two overlays modify the same property, the last one wins. If they both try to enable the same peripheral with different settings, the result depends entirely on the order they appear in `config.txt` or the bootloader's overlay list
- **The device tree is not validated against actual hardware** -- You can describe a device that does not physically exist on the board. The kernel will try to probe it, the driver will attempt to communicate with the device, and the probe will fail (or worse, succeed by reading garbage from an unpopulated bus). The device tree is a description, not a discovery mechanism -- it trusts you to describe the hardware accurately
- **Device tree changes require a reboot in most configurations** -- There is no hot-reload mechanism. The kernel consumes the device tree at boot and builds its device model from it. Changing the DTB or an overlay means rebooting to pick up the changes. Some experimental runtime overlay mechanisms exist, but they are fragile and not widely used in production
- **`#address-cells` and `#size-cells` in parent nodes determine how child `reg` properties are interpreted** -- These properties specify how many 32-bit cells make up an address and a size in child nodes' `reg` properties. Getting them wrong produces subtly incorrect register addresses: the driver reads from the wrong memory location, and the result is either a bus error or silent data corruption. When copying nodes between device trees, always verify that the parent's `#address-cells` and `#size-cells` match the source context
